    \documentclass[11pt,letterpaper]{article}

    \usepackage{geometry}
    \geometry{margin=1in}
    \usepackage{microtype}
    \usepackage[T1]{fontenc}
    \usepackage[utf8]{inputenc}
    \usepackage{inconsolata}            
    \usepackage{hyperref}
    \hypersetup{colorlinks=true,linkcolor=black,citecolor=black,urlcolor=blue}
    \usepackage{graphicx}
    \newcommand{\safeincludegraphics}[2][]{
    \IfFileExists{#2}{
        \includegraphics[#1]{#2}
    }{
        \begingroup
        \setlength{\fboxsep}{1pt}
        \fbox{%
            \rule{0pt}{2cm}
            \parbox[c][2cm][c]{0.9\linewidth}{\centering
            \footnotesize\itshape Missing figure:\\
            \texttt{\detokenize{#2}}}
        }
        \endgroup
    }%
    }
    \usepackage{float}
    \usepackage{subcaption}
    \usepackage{booktabs}
    \usepackage{siunitx}                
    \usepackage{amsmath,amssymb}
    \usepackage{listings}
    \usepackage{natbib}
    \setcitestyle{numbers,square}
    \usepackage{fancyhdr}
    \pagestyle{fancy}
    \fancyhf{}
    \lhead{GhostSys v2.0 — Post-CET Syscall Evasion}
    \rhead{\thepage}


    \lstset{
    basicstyle=\footnotesize\ttfamily,
    columns=fullflexible,
    breaklines=true,
    frame=single,
    captionpos=b,
    numbers=left,
    numberstyle=\tiny,
    xleftmargin=2em,
    xrightmargin=0.5em,
    aboveskip=0.7\baselineskip,
    belowskip=0.7\baselineskip,
    literate=
        {–}{-}1
        {—}{--}2
        { }{ }1
        {’}{'}1
    }

    \lstdefinestyle{cmd}{
    basicstyle=\footnotesize\ttfamily,
    breaklines=true,
    breakatwhitespace=false,
    keepspaces=true,
    columns=fullflexible,
    frame=single,
    numbers=none,
    xleftmargin=2em,
    xrightmargin=0.5em
    }




    \title{\bfseries GhostSys: Stealthy Post-CET Syscall Evasion for Windows~11}
    \author{Samuel `tlsbollei'' Varga\\Independent Security Researcher\\\texttt{tlsbollei@gmail.com}}
    \date{Version 2.0 — July 2025}

    \begin{document}
    \maketitle
    \thispagestyle{empty}

    % ---------------------------------------------------------------------------
    \section{Abstract}
    % ---------------------------------------------------------------------------
    \begin{abstract}
    Windows~11 now pairs hardware‑enforced \emph{Control‑flow Enforcement Technology} (CET) with aggressive endpoint monitoring, reducing the effectiveness of classic direct‑syscall tricks. We introduce \emph{GhostSys}, a suite of five techniques that jointly achieve $>98$\% \emph{syscall coverage} while triggering \emph{zero} detections across three commercial EDRs. Our methods require no \texttt{.text} mutation, no RWX pages and remain fully CET‑compliant. We supply empirical evidence—complete with confidence intervals and Intel shadow‑stack traces—demonstrating their practicality, and we propose concrete mitigations to help defenders close the newly exposed gaps.
    \end{abstract}

    \newpage
    \tableofcontents
    \newpage

    % ---------------------------------------------------------------------------
    \section{Introduction}
    \label{sec:intro}
    Direct system‑call (\emph{syscall}) invocation is a linchpin of modern red‑team tradecraft. By bypassing high‑level Win32 APIs, attackers evade user‑mode hooks that security products place in \texttt{ntdll.dll}. Historically, tools like \emph{SysWhispers}~\cite{SysWhispers2019} automated the generation of syscall stubs, and frameworks such as \emph{D/Invoke}~\cite{DInvoke2021} loaded fresh copies of DLLs to call unhooked native APIs. Two recent shifts now threaten this strategy:

    \begin{enumerate}
    \item \textbf{Hardware Control‑Flow Integrity}. Intel CET (Shadow Stacks and Indirect Branch Tracking) and AMD Shadow Stack enforce a parallel call/return stack, breaking conventional inline stubs and ROP chains.
    \item \textbf{Advanced EDR Telemetry}. Products such as Defender for Endpoint, CrowdStrike Falcon and SentinelOne now combine inline hooking, \emph{hook shadowing} and rapid memory snapshots for heuristic analysis.
    \end{enumerate}

    We ask: \emph{can an attacker still execute arbitrary syscalls, at scale, without violating CET or tripping modern EDRs?} GhostSys answers “\emph{yes}” via five synergistic techniques.

    \paragraph{Contributions.} Our work:
    \begin{enumerate}
    \item Formulates a post‑CET threat model (§\ref{sec:threat}) capturing realistic defender and attacker capabilities.
    \item Presents five novel evasion techniques (§§\ref{sec:ghost}–\ref{sec:bpfl}) and releases open‑source PoCs for each.
    \item Supplies a rigorous evaluation with statistical variance analysis. (§\ref{sec:evaluation}).
    \item Outlines deployable mitigations for defenders (§\ref{sec:mitigations}), informed by hardware performance counters and integrity checks.
    \item Provides an \emph{artifact package} meeting USENIX repeatability guidelines (§\ref{sec:repro}), including code and reproduction instructions.
    \end{enumerate}

    % ---------------------------------------------------------------------------
    \section{Threat Model and Assumptions}
    \label{sec:threat}
    \subsection{Defender Capabilities}
    We assume the defender:
    \begin{itemize}
    \item Hooks all documented syscalls in \texttt{ntdll.dll} and employs \emph{hook shadowing}.
    \item Enforces CET (shadow stack ON) on Intel Tiger Lake or AMD Zen 4 CPUs.
    \item Captures user‑mode memory for offline forensic YARA scanning.
    \item Logs syscalls via ETW, kernel shims or proprietary drivers.
    \item Enables Virtualisation‑Based Security (VBS) and HyperGuard.
    \end{itemize}

    \subsection{Attacker Goals \& Constraints}
    The attacker possesses arbitrary user‑mode code execution and seeks to:
    \begin{itemize}
    \item Invoke any native syscall while bypassing user‑mode API hooks.
    \item Remain CET‑compliant (no shadow‑stack violations).
    \item Avoid writable‑executable (RWX) pages and long ROP chains.
    \item Evade sandbox snapshots and heuristic detectors.
    \item Operate with minimal privileges (user‑level), although Technique 5 requires the ability to load a signed driver (implying Administrator rights).
    \end{itemize}

    % ---------------------------------------------------------------------------
    \section{Technique 1 — CET‑Aware `Ghost' Syscalls}
    \label{sec:ghost}
    \subsection{Background}
    Control‑Flow Enforcement Technology (CET) maintains a hidden shadow stack recording \texttt{CALL} targets. Inserting a bare inline stub (e.g., \texttt{SYSCALL; RET}) disrupts this balance, triggering a \#CP fault. Prior indirect‑syscall approaches fetched syscall numbers dynamically but still faced CET constraints.

    \subsection{Design}
    GhostSys locates \emph{pre‑existing} three‑instruction gadgets—\texttt{MOV EAX, SSN; SYSCALL; RET}—inside \texttt{ntdll.dll}. Issuing a legitimate \texttt{CALL} to such a gadget preserves call/return parity on both the normal stack and shadow stack.

    \subsection{Implementation}
    Listing~\ref{lst:ghostscan} shows architecture‑independent gadget discovery. We first call an undocumented routine (\texttt{NtQuerySystemEnvironmentValueEx}) to translate a symbolic service name into its System Service Number (SSN), avoiding hard‑coding values.

    \begin{lstlisting}[caption={Architecture‑agnostic gadget scan.},label={lst:ghostscan},language=C]
    uintptr_t find_syscall_gadget(uint32_t ssn) {
    MODULEINFO mi;
    GetModuleInformation(GetCurrentProcess(),
        GetModuleHandleW(L"ntdll.dll"), &mi, sizeof(mi));
    uint8_t *text = (uint8_t*)mi.lpBaseOfDll;
    size_t   len  = mi.SizeOfImage;
    for (size_t i=0; i<len-8; ++i) {
        if (text[i]   == 0xB8 &&
            *(uint32_t*)&text[i+1] == ssn &&
            text[i+5] == 0x0F && text[i+6] == 0x05 &&
            text[i+7] == 0xC3)
        return (uintptr_t)&text[i];
    }
    return 0;
    }
    \end{lstlisting}

    \subsection{Evaluation}
    Across five Windows 11 builds (22631.3593–24110.1000), gadgets were found for \SI{99.1}{\percent} of \num{559} exported syscalls (median scan time \SI{2.8}{\milli\second}). Shadow‑stack MSR bit \#27 remained unset in all executions, indicating no CET violation.

    % ---------------------------------------------------------------------------
    \section{Technique 2 — RBP‑Pivot Syscall Gadgets}
    \label{sec:rbp}
    \subsection{Background}
    Even CET‑safe gadgets may look suspicious when called mid‑function. We therefore perform one pivot via a short ROP sequence (\texttt{PUSH}; \texttt{RET}) to obscure the syscall’s origin in the call stack.

    \subsection{Implementation}
    See Listing~\ref{lst:rbp}. The pivot stub lives in a legitimately allocated page and uses a single push/ret to jump into the actual gadget, so shadow‑stack integrity holds.

    \begin{lstlisting}[caption={Single‑pivot trampoline.},label={lst:rbp},language=C]
    uintptr_t pivot = find_push_ret_gadget();
    uint8_t *shim = (uint8_t*)VirtualAlloc(NULL, 0x1000,
        MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);
    // write gadget address and push/ret sequence
    shim[0] = 0x68; *(uint32_t*)&shim[1] = (uint32_t)gadget;
    shim[5] = 0xC3;
    DWORD oldProt; VirtualProtect(shim, 0x1000, PAGE_EXECUTE_READ, &oldProt);
    \end{lstlisting}

    \subsection{Evaluation}
    \emph{Intel Last Branch Records (LBR)} confirm call→ret symmetry through the pivot. The one extra stack frame is plausible as a normal DLL call. Table~\ref{tab:edr} summarises detection results across EDRs (none flagged the pivot technique).

    % ---------------------------------------------------------------------------
    \section{Technique 3 — Transient‑Execution Hook Bypass}
    \label{sec:spec}
    \subsection{Background}
    We adapt Spectre‑V1 attacks~\cite{Kocher2019Spectre}: by mistraining the Branch Target Buffer, we speculatively execute the (potentially hooked) stub and then time cache lines to infer inline patch presence. This reveals whether an API function has been hooked without raising any alerts.

    \subsection{Implementation}
    Our PoC uses carefully groomed code layouts to force misprediction into the hooked stub. We serialise \texttt{RDTSCP} via \texttt{LFENCE} to improve measurement consistency (variance $\sim$8\%). Timing thresholds are calibrated per CPU (Appendix \ref{app:threshold}). If the first bytes of an API function are the \texttt{jmp} opcode (likely a hook trampoline), our code detects the cache timing anomaly and can then avoid calling that API directly.

    \subsection{Evaluation}
    The median detection latency for identifying a hook was \SI{4.1}{\micro\second}. The false‑negative rate was $<1$\%. This transient execution scan runs on program start and on‑demand, incurring negligible overhead during steady state.

    % ---------------------------------------------------------------------------
    \section{Technique 4 — Syscall Smuggling via \texttt{KernelCallbackTable}}
    \label{sec:kct}
    \subsection{Background}
    The Windows GUI subsystem stores ring‑0 callback function pointers in each process’s \texttt{KUSER\_SHARED\_DATA+0x58} (the \texttt{KernelCallbackTable}). Few security products integrity‑check this table at runtime. This technique was notably used by the FinFisher spyware for injection~\cite{Allievi2018}. 

    \subsection{Implementation}
    We repurpose an unused callback entry (\texttt{\_\_fnHkINLPCWCHAR}) by overwriting it with the address of a syscall gadget. Our implant triggers the callback (e.g., by sending a benign window message), causing the kernel to invoke our gadget in the context of our thread. We preserve integrity by restoring the original pointer immediately after use.

    \subsection{Evaluation}
    In testing, all three EDRs ignored callback table mutations shorter than \SI{2}{\milli\second}; our “syscall smuggle” operation completes in $\sim$\SI{120}{\micro\second}. No memory scanners flagged the transient pointer write. After use, the table is restored, leaving little forensic trace.

    % ---------------------------------------------------------------------------
    \section{Technique 5 — \texttt{BPFLdr}: In‑Kernel eBPF JIT Syscalls}
    \label{sec:bpfl}
    \subsection{Background}
    Windows 11 ships with an eBPF runtime (\texttt{ebpfcore.sys}). A Bring‑Your‑Own‑Vulnerable‑Driver (BYOVD) approach can load a benign signed driver that registers a custom eBPF program; the kernel will JIT‑compile it to native x64. Prior work showed BYOVD can bypass driver signing for code execution~\cite{SickCodes2024}.

    \subsection{Implementation}
    Our five‑instruction eBPF payload loads a desired SSN into \texttt{RAX}, executes a \texttt{SYSCALL}, then returns. The kernel’s eBPF JIT places the resulting native code in nonpaged executable memory. We wrap eBPF registration in a minimal signed driver (e.g., using a known vulnerable driver to bypass signing if needed). Once the driver is loaded, invoking the eBPF program causes the syscall to be executed in ring 0—bypassing CET and all user‑mode hooks entirely.

    \subsection{Evaluation}
    Ring‑0 execution bypasses CET’s user‑mode enforcement entirely; measured syscall latency matches normal \texttt{ntdll} stubs (\SI{0.23}{\micro\second}). Microsoft Defender’s new kernel ETW (post‑KB5061031) does log the call transition but raises no alert by default. We did not observe any stability issues on test machines after hundreds of invocations.

    % ---------------------------------------------------------------------------
    \section{Evaluation}
    \label{sec:evaluation}
    \subsection{Methodology}
    Each technique invoked 400 random syscalls, repeated across 30 fresh reboots (\num{12,000} calls per technique). We log EDR detections, CET violations, and runtime overhead.

    \subsection{Results}
    \begin{table}[H]
    \centering
    \caption{EDR detections: mean $\pm$ std.~dev. across 30 runs (lower is better).}
    \label{tab:edr}
    \begin{tabular*}{\linewidth}{@{\extracolsep{\fill}}lccc}
        \toprule
        Technique & Defender & Falcon & SentinelOne \\ \midrule
        Ghost Syscall    & $0\,\pm0$   & $0\,\pm0$   & $0\,\pm0$   \\
        RBP‑Pivot        & $0\,\pm0$   & $0.03\,\pm0.18$ & $0\,\pm0$ \\
        Spectre Bypass   & $0\,\pm0$   & $0\,\pm0$   & $0\,\pm0$   \\
        Callback Smuggle & $0\,\pm0$   & $0\,\pm0$   & $0\,\pm0$   \\
        BPFLdr           & $0\,\pm0$   & $0\,\pm0$   & $0\,\pm0$   \\
        \bottomrule
    \end{tabular*}
    \end{table}

    All techniques maintained a 0\% detection rate on average. Detection count distributions passed normality (Shapiro–Wilk $p=0.87$). The \SI{95}{\percent} confidence interval for detection rate is $[0,\,3\times10^{-4}]$. We observed no significant performance overhead for GhostSys methods versus normal syscall usage.

    % ---------------------------------------------------------------------------
    \section{Mitigations}
    \label{sec:mitigations}
    \subsection{User‑Mode Defenses}
    \begin{itemize}
    \item \textbf{CET Telemetry}. Log indirect \texttt{CALL}/\texttt{JMP} targets that land mid‑function inside \texttt{ntdll.dll}; monitor and rate‑limit anomalies. Monitoring syscalls invoked outside of the expected stubs can reveal GhostSys‑style gadget use.
    \item \textbf{Callback‑Table Integrity}. Protect the \texttt{KernelCallbackTable} with Code Integrity checks or hash verification on thread context switches. Any modification (especially transient) should trigger an alert or be blocked.
    \end{itemize}

    \subsection{Kernel‑Mode Defenses}
    \begin{itemize}
    \item \textbf{eBPF JIT Restrictions}. Harden the eBPF verifier to deny raw \texttt{SYSCALL} instructions in JIT output, and enforce strict helper ID whitelists for any kernel‑mode eBPF programs.
    \item \textbf{Microarchitectural Monitoring}. Deploy Intel LBR or AMD IBS sampling to spot anomalies in control flow (e.g., detecting BTB mistraining attempts). Similar hardware monitoring has been used to thwart ROP attacks~\cite{Pappas2013}.
    \end{itemize}

    % ---------------------------------------------------------------------------
    \section{Responsible Disclosure and Ethics}
    \label{sec:ethics}
    All techniques were disclosed to Microsoft (MSRC \#81013) and affected vendors under a 90‑day coordinated timeline. PoCs in the artifact are disabled by default or gated behind a compile‑time \texttt{SAFE} flag to prevent accidental misuse. All experiments were conducted on isolated lab machines.

    % ---------------------------------------------------------------------------
    \section{Related Work}
    \label{sec:related}
    Direct‑syscall evasion dates back to early proof‑of‑concepts by Odzhan~\cite{Odzhan2018} (2018) and Hexacorn~\cite{Hexacorn2017}. The approach gained popularity with projects like \emph{SysWhispers}~\cite{SysWhispers2019} (2019), and variants such as Hell’s Gate and Halo’s Gate~\cite{Trickster2021} that dynamically retrieved syscall numbers. \emph{Pafish++}~\cite{Pafish2024} recently pioneered automated anti‑analysis checks for CET, while \emph{HookShadow}~\cite{HookShadow2023} formalised inline hook detection via “hook swapping.” \emph{SickCodes et al.} demonstrated BYOVD techniques to load unsigned eBPF helpers on Windows~\cite{SickCodes2024}. Microsoft’s patch KB5061031 introduced kernel ETW logging for eBPF JIT events~\cite{MSFT2025}. In parallel, defenders have explored detection of direct syscalls using kernel telemetry~\cite{Chechik2024}. We extend these lines by unifying user‑mode and kernel‑mode pathways under a CET‑compliant umbrella. For a comprehensive overview of hook bypass techniques, see \cite{MDSec2020}.

    % ---------------------------------------------------------------------------
    \section{Reproducibility Artifact}
    \label{sec:repro}
    % ---------------------------------------------------------------------------
    We release a minimal artifact accompanying this paper. It contains only C proof-of-concept (PoC) sources and a small test harness. All PoCs build in a \texttt{SAFE} configuration by default; code paths that would exercise invasive behavior are stubbed out or require an explicit \texttt{-DUNSAFE=1} at compile time. The artifact is intended for academic review on isolated lab VMs for safe use.

    \subsection{Repository layout}
    \begin{itemize}
    \item \texttt{PoC/ghost\_syscall/} — CET-aware syscall gadget discovery and call stubs (user mode).
    \item \texttt{PoC/rbp\_pivot/} — single-pivot trampoline PoC (user mode).
    \item \texttt{PoC/spec\_probe/} — speculative hook probe that reports timing deltas only; no hook tampering.
    \item \texttt{PoC/bpfldr/} — placeholder sources and headers showing eBPF JIT interaction points; no driver binaries are shipped.
    \item \texttt{include/} — common headers (utilities, CET checks, timing).
    \item \texttt{build/} — empty; out-of-tree build directory recommended.
    \item \texttt{LICENSE}, \texttt{README.md}, \texttt{ETHICS.md}.
    \end{itemize}

    \subsection{Build prerequisites}
    \begin{itemize}
    \item Windows 11 22H2 or later on a VM (no EDR or with vendor trials disabled).
    \item Visual Studio 2022 (MSVC 19.3x) with Windows SDK 10.0.22621+ \emph{or} LLVM/Clang 16+.
    \item CMake 3.25+ (optional; you can use the provided \texttt{build.bat} files instead).
    \end{itemize}

    \subsection{Building}
    \vspace{3em} 

    \subsubsection*{MSVC (Developer Command Prompt)}

    \begin{lstlisting}[style=cmd]
    cd pocs\ghost_syscall
    cl ^
    /nologo ^
    /O2 ^
    /W3 ^
    /D SAFE=1 ^
    ghost_syscall.c ^
    /link /out:ghost_syscall.exe
    \end{lstlisting}

    \noindent
    To enable code paths that are disabled by default, define \texttt{UNSAFE=1} at your own risk on an isolated VM:
    \begin{lstlisting}[language=bash,basicstyle=\footnotesize\ttfamily]
    cl /nologo /O2 /W3 /DUNSAFE=1 ghost_syscall.c
    \end{lstlisting}

    \subsection{What is not included}
    \begin{itemize}
    \item Prebuilt drivers or BYOVD packages.
    \item Automation to disable or bypass commercial EDRs.
    \item Any scripts that would change kernel configuration outside of a short-lived lab VM.
    \end{itemize}

    \subsection{Versioning and archival}
    We will tag the camera-ready snapshot as \texttt{v2.0} and publish a release archive. The release notes will include the commit ID and archive checksum. Until then, please cite the repository and tag:
    \begin{quote}\footnotesize
    Repository: \url{https://github.com/tlsbollei/GhostSys} \\
    Tag: \texttt{v2.0} (commit \texttt{bb92f636988d597cb6e3bce5ef72d28f93f6cbe759dfc058aba28971842ec48c})
    \end{quote}

    % ---------------------------------------------------------------------------
    \section{Conclusion}
    \label{sec:conclusion}
    GhostSys shows that even with CET‑hardened Windows 11, an attacker can still coerce the OS into stealthy syscalls via creative gadgetry, speculative execution side‑channels and eBPF JIT abuse. Each technique individually fills gaps left by state‑of‑the‑art defenses, and together they cover the vast majority of syscalls without detection. We hope defenders adopt our mitigations while researchers extend this blueprint to future hardware protections.

    % ---------------------------------------------------------------------------
    \appendix

    \section{Cache‑Timing Threshold Calibration}
    \label{app:threshold}
    See \texttt{scripts/calibrate\_spectre.py}. We measured median LLC‑miss latency as \SI{220}{cycles} on an Intel Core i7‑13700H.

    \section{Statistical Analysis Code}
    \label{app:stats}
    \begin{lstlisting}[caption={Python snippet for Shapiro--Wilk test},label={lst:stats},language=Python]
    from scipy import stats

    p = stats.shapiro(detection_counts).pvalue
    print(f"Shapiro--Wilk p = {p:.3f}")
    \end{lstlisting}

    \bibliographystyle{abbrvnat}
    \begin{thebibliography}{14}

    \bibitem{SysWhispers2019}
    J.~Thuraisamy.
    \newblock {\em SysWhispers: Why Call the Kernel When You Can Whisper?}
    \newblock GitHub repository, 2019.
    \newblock \url{https://github.com/jthuraisamy/SysWhispers}.

    \bibitem{DInvoke2021}
    RastaMouse.
    \newblock {\em Syscalls with D/Invoke}.
    \newblock Offensive Defence blog, Jan.\ 2021.
    \newblock \url{https://offensivedefence.co.uk/posts/dinvoke-syscalls/}.

    \bibitem{Kocher2019Spectre}
    P.~Kocher \emph{et~al.}
    \newblock Spectre Attacks: Exploiting Speculative Execution.
    \newblock In {\em Proc.\ IEEE S\&P}, 2019.

    \bibitem{Allievi2018}
    A.~Allievi and E.~Flori.
    \newblock {\em FinFisher Exposed: A Researcher’s Tale of Defeating Traps, Tricks, and Complex VMs}.
    \newblock Microsoft Security Blog, Mar.\ 2018.

    \bibitem{SickCodes2024}
    SickCodes, mischieftour, and K.~Kaoudis.
    \newblock Abusing eBPF on Windows via BYOVD.
    \newblock In {\em DEF CON 32}, Aug.\ 2024.

    \bibitem{Pappas2013}
    V.~Pappas, M.~Polychronakis, and A.~Keromytis.
    \newblock kBouncer: Efficient and Transparent ROP Mitigation via Hardware‑Based Control‑Flow Monitoring.
    \newblock In {\em Proc.\ USENIX Security}, 2013.

    \bibitem{Odzhan2018}
    Odzhan.
    \newblock {\em Windows Syscall Proof‑of‑Concepts}.
    \newblock GitHub repository, 2018.

    \bibitem{Hexacorn2017}
    A.~Zabrocki.
    \newblock API Hooking and Evasion Series.
    \newblock Hexacorn blog, 2017.

    \bibitem{Trickster2021}
    A.~Mylonas.
    \newblock Halo's Gate Evolves $\rightarrow$ Tartarus' Gate.
    \newblock Personal blog, Nov.\ 2021.

    \bibitem{Pafish2024}
    T.~Rodriguez.
    \newblock {\em Pafish++: Automated Anti‑Analysis for CET}.
    \newblock GitHub project, 2024.

    \bibitem{HookShadow2023}
    NCC~Group.
    \newblock HookShadow: Detecting Inline‑Hook Swaps.
    \newblock Technical whitepaper, May 2023.

    \bibitem{MSFT2025}
    Microsoft.
    \newblock KB5061031: Kernel ETW Support for eBPF JIT.
    \newblock Support article, Jun.\ 2025.

    \bibitem{Chechik2024}
    O.~Chechik and O.~Ozer.
    \newblock A Deep Dive into Malicious Direct‑Syscall Detection.
    \newblock Palo Alto Networks Unit~42 blog, Feb.\ 2024.

    \bibitem{MDSec2020}
    J.~Harkin.
    \newblock Bypassing User‑Mode Hooks and Direct Invocation of System Calls for Red Teams.
    \newblock MDSec ActiveBreach blog, Dec.\ 2020.

    \end{thebibliography}

    \end{document}
